//
//
// Tencent is pleased to support the open source community by making tRPC available.
//
// Copyright (C) 2023 Tencent.
// All rights reserved.
//
// If you have downloaded a copy of the tRPC source code from Tencent,
// please note that tRPC source code is licensed under the  Apache 2.0 License,
// A copy of the Apache 2.0 License is included in this file.
//
//

#include "trpc/tools/comm/utils.h"

#include <algorithm>
#include <cassert>
#include <ctime>
#include <memory>
#include <sstream>

#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/io/zero_copy_stream.h"

namespace trpc::tools {

const char* kDeclaration =
    "//\n"
    "// This file was generated by trpc_cpp_plugin which is a self-defined pb compiler plugin, do "
    "not edit it!!!\n"
    "// All rights reserved by Tencent Corporation\n"
    "//\n\n";

const char* kIndent = "  ";
const char* kSpace = " ";

std::string ProtoFileBaseName(const std::string& fullName) {
  std::size_t p = fullName.rfind(".");
  assert(p != std::string::npos);

  return fullName.substr(0, p);
}

std::string ProtoFileServerName(const std::string& packageName) {
  std::vector<std::string> vt = SepStr(packageName, ".");
  assert(vt.size() == 3);  // trpc.appname.servername
  assert(vt[2].size() != 0);
  return vt[2];
}

std::string ProtoFileAppName(const std::string& packageName) {
  std::vector<std::string> vt = SepStr(packageName, ".");
  assert(vt.size() == 3);  // trpc.appname.servername
  assert(vt[1].size() != 0);
  return vt[1];
}

std::string LineFeed(int indent) {
  std::string data("\n");

  for (int i = 0; i < indent; ++i) {
    data += kIndent;
  }

  return data;
}

std::vector<std::string> SepStr(const std::string& sStr, const std::string& sSep) {
  std::vector<std::string> vt;

  std::string::size_type pos = 0;
  std::string::size_type pos1 = 0;
  int pos_tmp = -1;

  while (true) {
    std::string s;
    std::string s1;
    pos1 = sStr.find_first_of(sSep, pos);
    if (pos1 == std::string::npos) {
      if (pos + 1 <= sStr.length()) {
        s = sStr.substr(-1 != pos_tmp ? pos_tmp : pos);
        s1 = "";
      }
    } else if (pos1 == pos && (pos1 + 1 == sStr.length())) {
      s = "";
      s1 = "";
    } else {
      s = sStr.substr(-1 != pos_tmp ? pos_tmp : pos, pos1 - (-1 != pos_tmp ? pos_tmp : pos));
      s1 = sStr.substr(pos1 + 1);
      if (-1 == pos_tmp) pos_tmp = pos;
      pos = pos1;
    }

    if (!s.empty()) {
      vt.push_back(s);
    }
    pos_tmp = -1;

    if (pos1 == std::string::npos) {
      break;
    }

    pos++;
  }

  return vt;
}

std::string GenNamespaceStr(const std::string& ns) {
  std::vector<std::string> vt = SepStr(ns, ".");

  std::string namespace_str("");
  for (size_t i = 0; i < vt.size(); ++i) {
    namespace_str += vt[i];
    if (i != (vt.size() - 1)) {
      namespace_str += "::";
    }
  }

  return namespace_str;
}

std::string GenNamespaceBegin(const std::string& ns) {
  std::string content;

  std::vector<std::string> vt = SepStr(ns, ".");
  for (size_t i = 0; i < vt.size(); ++i) {
    content += "\nnamespace " + vt[i] + " {";
  }

  return content;
}

std::string GenNamespaceEnd(const std::string& ns) {
  std::string content;

  std::vector<std::string> vt = SepStr(ns, ".");
  for (int i = vt.size() - 1; i >= 0; --i) {
    content += "\n} // end namespace " + vt[i];
  }

  return content;
}

// convert pb method's input and output paramter type to c++ namespace scoped type
// e.g. trpc.test.helloworld.HelloRequest produce ::trpc::test::helloworld::HelloRequest
std::string GetParamterTypeWithNamespace(const std::string& typeFullName) {
  if (typeFullName == "") {
    return "";
  }

  std::string typeRealName = "::";  // From top namespace to prevent namespace conflicts.
  auto vt = SepStr(typeFullName, ".");
  for (size_t i = 0; i < vt.size() - 1; ++i) {
    typeRealName += vt[i] + "::";
  }
  return typeRealName + vt[vt.size() - 1];
}

bool NeedMock(const std::string& parameter) {
  if (parameter.empty()) {
    return false;
  }

  bool need_mock = false;
  auto parameters_list = SepStr(parameter, ",");
  for (const auto& param : parameters_list) {
    auto kv = SepStr(param, "=");
    if (kv.size() != 2) {
      continue;
    }
    if (kv[0] == "generate_mock_code" && kv[1] == "true") {
      need_mock = true;
      continue;
    }
    if (kv[0] == "generate_new_mock_code" && kv[1] == "true") {
      need_mock = true;
      continue;
    }
  }
  return need_mock;
}

bool NeedGenStubForExternalRepo(const std::string& parameter, std::string* external_repo_stub_path) {
  if (parameter.empty()) {
    return false;
  }

  bool need_gen = false;
  auto parameters_list = SepStr(parameter, ",");
  for (const auto& param : parameters_list) {
    auto kv = SepStr(param, "=");
    if (kv.size() != 2) {
      continue;
    }
    if (kv[0] == "generate_trpc_stub_path") {
      need_gen = true;
      *external_repo_stub_path = kv[1];
    }
  }
  return need_gen;
}

void ParseRelativeProtoImportPath(const std::string& parameter, std::string* proto_include_prefix) {
  // When a proto file import another proto file, it can import using relative import.
  // This situation requires special handling.
  auto params = SepStr(parameter, ",");
  for (const auto& param : params) {
    auto kv = SepStr(param, "=");
    if (kv.size() == 0) {
      continue;
    }
    if (kv[0] != "proto_include_prefix") {
      continue;
    }
    if (kv.size() == 1) {
      // When generate stub code using custom protoc paramter: proto_include_prefix=, it means that import proto in
      // current direcotry. The generated xxx.pb.h file will be located at project root, so the generated xxx.trpc.pb.h
      // should include xxx.pb.h file without any prefix path.
      *proto_include_prefix = "";
    } else {
      // xxx.pb.h will be generated at relative path from project root.
      *proto_include_prefix = kv[1];
    }
    break;
  }
}

bool NeedEnableExplicitLinkProto(const std::string& parameter) {
  if (parameter.empty()) {
    return false;
  }

  auto parameters_list = SepStr(parameter, ",");
  for (const auto& param : parameters_list) {
    auto kv = SepStr(param, "=");
    if (kv.size() != 2) {
      continue;
    }
    if (kv[0] == "enable_explicit_link_proto") {
      return true;
    }
  }
  return false;
}

void WriteToFile(google::protobuf::compiler::GeneratorContext* context, const std::string& file_name,
                 const std::string& file_context) {
  std::unique_ptr<google::protobuf::io::ZeroCopyOutputStream> output(context->Open(file_name));
  google::protobuf::io::CodedOutputStream coded_out(output.get());
  coded_out.WriteRaw(file_context.data(), file_context.size());
}

bool ContainStreamMethod(const google::protobuf::FileDescriptor* file) {
  for (int i = 0; i < file->service_count(); ++i) {
    auto service = file->service(i);
    for (int j = 0; j < service->method_count(); j++) {
      auto method = service->method(j);
      bool client_stream = method->client_streaming();
      bool server_stream = method->server_streaming();
      if (client_stream || server_stream) {
        return true;
      }
    }
  }

  return false;
}

bool CheckProtoFileValid(const google::protobuf::FileDescriptor* file, std::string* error) {
  bool ok = true;
  if (file == nullptr) {
    error->append(" FileDescriptor is null!!!");
    return false;
  }
  if (file->name().empty()) {
    error->append(" proto file name is missed!!!");
    ok = false;
  }
  if (file->package().empty()) {
    error->append(" proto file package name is missed!!!");
    ok = false;
  }
  return ok;
}

}  // namespace trpc::tools
