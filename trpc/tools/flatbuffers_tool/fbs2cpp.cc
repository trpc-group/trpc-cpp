//
// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// Copy and modify from https://github.com/google/flatbuffers/blob/v23.5.26/grpc/src/compiler/cpp_generator.cc.

#include "fbs2cpp.h"

#include <map>
#include <sstream>

#include "flatbuffers/util.h"

namespace trpc_cpp_generator {
namespace {

std::string service_header_ext() { return ".trpc.fb.h"; }

template <class T>
std::string as_string(T x) {
  std::ostringstream out;
  out << x;
  return out.str();
}

inline bool ClientOnlyStreaming(const Method* method) {
  return method->ClientStreaming() && !method->ServerStreaming();
}

inline bool ServerOnlyStreaming(const Method* method) {
  return !method->ClientStreaming() && method->ServerStreaming();
}

std::string FilenameIdentifier(const std::string& filename) {
  std::string result;
  for (unsigned i = 0; i < filename.size(); i++) {
    char c = filename[i];
    if (isalnum(c)) {
      result.push_back(c);
    } else {
      static char hex[] = "0123456789abcdef";
      result.push_back('_');
      result.push_back(hex[(c >> 4) & 0xf]);
      result.push_back(hex[c & 0xf]);
    }
  }
  return result;
}
}  // namespace

template <class T, size_t N>
T* array_end(T (&array)[N]) {
  return array + N;
}

void PrintIncludes(Printer* printer, const std::vector<std::string>& headers, const Parameters& params) {
  std::map<std::string, std::string> vars;

  vars["l"] = params.use_system_headers ? '<' : '"';
  vars["r"] = params.use_system_headers ? '>' : '"';

  auto& s = params.trpc_search_path;
  if (!s.empty()) {
    vars["l"] += s;
    if (s[s.size() - 1] != '/') {
      vars["l"] += '/';
    }
  }

  for (auto i = headers.begin(); i != headers.end(); i++) {
    vars["h"] = *i;
    printer->Print(vars, "#include $l$$h$$r$\n");
  }
}

std::string GetHeaderPrologue(File* file, const Parameters& params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    vars["filename"] = file->FileName();
    vars["filename_identifier"] = FilenameIdentifier(file->FileName());
    vars["filename_base"] = file->FileNameWithoutExt();
    vars["message_header_ext"] = params.message_header_extension;

    printer->Print(vars, "//\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "// Tencent is pleased to support the open source community by making tRPC available.\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "// Copyright (C) 2023 Tencent.\n");
    printer->Print(vars, "// All rights reserved.\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "// If you have downloaded a copy of the tRPC source code from Tencent,\n");
    printer->Print(vars, "// please note that tRPC source code is licensed under the  Apache 2.0 License,\n");
    printer->Print(vars, "// A copy of the Apache 2.0 License is included in this file.\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "\n");

    printer->Print(vars, "// This file was generated by trpc_fbs_plugin  compiler plugin, do not edit it!!!.\n");
    printer->Print(vars, "// If you make any local change, they will be lost.\n");
    printer->Print(vars, "// source: $filename$\n");
    printer->Print(vars, "\n");
    std::string leading_comments = file->GetLeadingComments("//");
    if (!leading_comments.empty()) {
      printer->Print(vars, "// Original file comments:\n");
      printer->Print(leading_comments.c_str());
    }
    printer->Print(vars, "#pragma once\n");
    printer->Print(vars, "\n");
    printer->Print(vars, "#include \"$filename_base$$message_header_ext$\"\n");
    printer->Print(vars, "\n");
    if (!file->AdditionalHeaders().empty()) {
      printer->Print(vars, file->AdditionalHeaders().c_str());
      printer->Print(vars, "\n");
    }
  }
  return output;
}

std::string GetHeaderIncludes(File* file, const Parameters& params) {
  std::string output;
  // Scope the output stream so it closes and finalizes output to the string.
  auto printer = file->CreatePrinter(&output);
  std::map<std::string, std::string> vars;

  static const char* headers_strs[] = {"trpc/util/flatbuffers/trpc_fbs.h"};
  printer->Print(vars, "\n");
  std::vector<std::string> headers(headers_strs, array_end(headers_strs));
  PrintIncludes(printer.get(), headers, params);
  printer->Print(vars, "\n");
  if (!file->Package().empty()) {
    std::vector<std::string> parts = file->PackageParts();

    for (auto part = parts.begin(); part != parts.end(); part++) {
      vars["part"] = *part;
      printer->Print(vars, "namespace $part$ {\n");
    }
    printer->Print(vars, "\n");
  }
  return output;
}

void PrintHeaderClientMethod(Printer* printer, const Method* method, std::map<std::string, std::string>* vars,
                             bool is_public) {
  (*vars)["Method"] = method->Name();
  (*vars)["Request"] = "flatbuffers::trpc::Message<" + method->InputTypeName() + ">";
  (*vars)["Response"] = "flatbuffers::trpc::Message<" + method->OutputTypeName() + ">";

  if (method->NoStreaming()) {
    printer->Print(*vars, "\n");
    printer->Indent();
    printer->Print(*vars,
                   "virtual ::trpc::Status $Method$(const ::trpc::ClientContextPtr& context, "
                   "const $ns$$Request$& request, $ns$$Response$* response);\n");
    printer->Print(*vars,
                   "virtual ::trpc::Future<$ns$$Response$> Async$Method$(const "
                   "::trpc::ClientContextPtr& context, "
                   "const $ns$$Request$& request);\n");
  }
  printer->Outdent();
}

void PrintHeaderServerMethodSync(Printer* printer, const Method* method, std::map<std::string, std::string>* vars) {
  (*vars)["Method"] = method->Name();
  (*vars)["Request"] = "flatbuffers::trpc::Message<" + method->InputTypeName() + ">";
  (*vars)["Response"] = "flatbuffers::trpc::Message<" + method->OutputTypeName() + ">";
  printer->Print(method->GetLeadingComments("//").c_str());
  if (method->NoStreaming()) {
    printer->Print(*vars, "\n");
    printer->Indent();
    printer->Print(*vars,
                   "virtual ::trpc::Status $Method$("
                   "const ::trpc::ServerContextPtr& context, const $ns$$Request$* request, "
                   "$ns$$Response$* response);\n");
  }
  printer->Print(method->GetTrailingComments("//").c_str());
  printer->Outdent();
}

void PrintHeaderService(Printer* printer, const Service* service, std::map<std::string, std::string>* vars) {
  (*vars)["Service"] = service->Name();
  (*vars)["ServiceProxy"] = service->Name() + "ServiceProxy";

  printer->Print(service->GetLeadingComments("//").c_str());
  printer->Print(*vars,
                 "class $Service$ : public ::trpc::RpcServiceImpl {\n"
                 " public:\n");
  printer->Indent();
  printer->Print(*vars, "$Service$();\n");
  printer->Outdent();
  for (int i = 0; i < service->MethodCount(); ++i) {
    PrintHeaderServerMethodSync(printer, service->Methods(i).get(), vars);
  }

  // printer->Outdent();
  printer->Print("};\n");
  printer->Print("\n");

  // client side - base
  printer->Print(*vars,
                 "class $ServiceProxy$ : public ::trpc::RpcServiceProxy {\n"
                 " public:");
  for (int i = 0; i < service->MethodCount(); ++i) {
    PrintHeaderClientMethod(printer, service->Methods(i).get(), vars, true);
  }
  printer->Print("};\n");

  printer->Print(service->GetTrailingComments("//").c_str());
}

std::string GetHeaderServices(File* file, const Parameters& params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;
    // Package string is empty or ends with a dot. It is used to fully qualify
    // method names.
    vars["Package"] = file->Package();
    if (!file->Package().empty()) {
      vars["Package"].append(".");
    }

    if (!params.services_namespace.empty()) {
      vars["services_namespace"] = params.services_namespace;
      vars["ns"] = params.services_namespace + "::";
      vars["prefix"] = params.services_namespace;
      printer->Print(vars, "\nnamespace $services_namespace$ {\n\n");
    } else {
      vars["ns"] = "";
      vars["prefix"] = "";
    }

    for (int i = 0; i < file->ServiceCount(); ++i) {
      if (file->IsCurrentFileService(i)) {
        PrintHeaderService(printer.get(), file->Services(i).get(), &vars);
        printer->Print("\n");
      }
    }

    if (!params.services_namespace.empty()) {
      printer->Print(vars, "}  // namespace $services_namespace$\n\n");
    }
  }
  return output;
}

std::string GetHeaderEpilogue(File* file, const Parameters& /*params*/) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    vars["filename"] = file->FileName();
    vars["filename_identifier"] = FilenameIdentifier(file->FileName());

    if (!file->Package().empty()) {
      std::vector<std::string> parts = file->PackageParts();

      for (auto part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer->Print(vars, "}  // namespace $part$\n");
      }
    }

    printer->Print(file->GetTrailingComments("//").c_str());
  }
  return output;
}

std::string GetSourcePrologue(File* file, const Parameters& /*params*/) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    vars["filename"] = file->FileName();
    vars["filename_base"] = file->FileNameWithoutExt();
    vars["service_header_ext"] = service_header_ext();

    printer->Print(vars, "//\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "// Tencent is pleased to support the open source community by making tRPC available.\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "// Copyright (C) 2023 Tencent.\n");
    printer->Print(vars, "// All rights reserved.\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "// If you have downloaded a copy of the tRPC source code from Tencent,\n");
    printer->Print(vars, "// please note that tRPC source code is licensed under the  Apache 2.0 License,\n");
    printer->Print(vars, "// A copy of the Apache 2.0 License is included in this file.\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "//\n");
    printer->Print(vars, "\n");
    printer->Print(vars, "// This file was generated by trpc_fbs_plugin  compiler plugin, do not edit it!!!.\n");
    printer->Print(vars, "// If you make any local change, they will be lost.\n");
    printer->Print(vars, "// source: $filename$\n\n");

    printer->Print(vars, "#include \"$filename_base$$service_header_ext$\"\n");
    printer->Print(vars, "\n");
    printer->Print(vars, "#include <functional>");
    printer->Print(vars, "\n");
    printer->Print(vars, "\n");
  }
  return output;
}

std::string GetSourceIncludes(File* file, const Parameters& params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    static const char* headers_strs[] = {"trpc/server/rpc_method_handler.h"};
    std::vector<std::string> headers(headers_strs, array_end(headers_strs));
    PrintIncludes(printer.get(), headers, params);

    printer->Print(vars, "\n");
    if (!file->Package().empty()) {
      std::vector<std::string> parts = file->PackageParts();

      for (auto part = parts.begin(); part != parts.end(); part++) {
        vars["part"] = *part;
        printer->Print(vars, "namespace $part$ {\n");
      }
    }

    printer->Print(vars, "\n");
  }
  return output;
}

void PrintSourceClientMethod(Printer* printer, const Method* method, std::map<std::string, std::string>* vars) {
  (*vars)["Method"] = method->Name();
  (*vars)["Request"] = "flatbuffers::trpc::Message<" + method->InputTypeName() + ">";
  (*vars)["Response"] = "flatbuffers::trpc::Message<" + method->OutputTypeName() + ">";

  if (method->NoStreaming()) {
    // sync
    printer->Print(*vars,
                   "::trpc::Status $Service$ServiceProxy::$Method$("
                   "const ::trpc::ClientContextPtr& context, "
                   "const $ns$$Request$& request, $ns$$Response$* response) {\n");

    printer->Print(*vars, "  context->SetFuncName($Service$_method_names[$Idx$]);\n");
    printer->Print(*vars, "  context->SetReqEncodeType(trpc::EncodeType::FLATBUFFER);\n");
    printer->Print(*vars,
                   "  return UnaryInvoke<$ns$$Request$, $ns$$Response$>("
                   "context, request, response);\n}\n\n");
    // async unary
    printer->Print(*vars,
                   "::trpc::Future<$ns$$Response$> $Service$ServiceProxy::Async$Method$("
                   "const ::trpc::ClientContextPtr& context, "
                   "const $ns$$Request$& request) {\n");
    printer->Print(*vars, "  context->SetFuncName($Service$_method_names[$Idx$]);\n");
    printer->Print(*vars, "  context->SetReqEncodeType(trpc::EncodeType::FLATBUFFER);\n");
    printer->Print(*vars,
                   "  return AsyncUnaryInvoke<$ns$$Request$, $ns$$Response$>("
                   "context, request);\n}\n");
  }
}

void PrintSourceServerMethod(Printer* printer, const Method* method, std::map<std::string, std::string>* vars) {
  (*vars)["Method"] = method->Name();
  (*vars)["Request"] = "flatbuffers::trpc::Message<" + method->InputTypeName() + ">";
  (*vars)["Response"] = "flatbuffers::trpc::Message<" + method->OutputTypeName() + ">";
  if (method->NoStreaming()) {
    printer->Print(*vars,
                   "::trpc::Status $Service$::$Method$("
                   "const ::trpc::ServerContextPtr& context, "
                   "const $ns$$Request$* request, $ns$$Response$* response) {\n");
    printer->Print("  (void) context;\n");
    printer->Print("  (void) request;\n");
    printer->Print("  (void) response;\n");
    printer->Print(
        "  return ::trpc::Status("
        "-1, \"\");\n");
    printer->Print("}\n\n");
  }
}

void PrintSourceService(Printer* printer, const Service* service, std::map<std::string, std::string>* vars) {
  (*vars)["Service"] = service->Name();

  if (service->MethodCount() > 0) {
    printer->Print(*vars, "static const char* $Service$_method_names[] = {\n");
    for (int i = 0; i < service->MethodCount(); ++i) {
      (*vars)["Method"] = service->Methods(i).get()->Name();
      printer->Print(*vars, "  \"/$Package$$Service$/$Method$\",\n");
    }
    printer->Print(*vars, "};\n\n");
  }

  printer->Print(*vars, "$ns$$Service$::$ns$$Service$() {\n");
  printer->Indent();
  for (int i = 0; i < service->MethodCount(); ++i) {
    auto method = service->Methods(i);
    (*vars)["Idx"] = as_string(i);
    (*vars)["Method"] = method->Name();
    (*vars)["Request"] = "flatbuffers::trpc::Message<" + method->InputTypeName() + ">";
    (*vars)["Response"] = "flatbuffers::trpc::Message<" + method->OutputTypeName() + ">";
    if (method->NoStreaming()) {
      printer->Print(*vars,
                     "AddRpcServiceMethod(\n"
                     "    new ::trpc::RpcServiceMethod($Service$_method_names[$Idx$], "
                     "::trpc::MethodType::UNARY,\n"
                     "                               new ::trpc::RpcMethodHandler<$ns$$Request$, "
                     "$ns$$Response$>(\n"
                     "                                   std::bind(&$Service$::$Method$, this, "
                     "std::placeholders::_1,\n"
                     "                                             std::placeholders::_2, "
                     "std::placeholders::_3))));\n");
    }
  }
  printer->Outdent();
  printer->Print(*vars, "}\n\n");

  // server side
  for (int i = 0; i < service->MethodCount(); ++i) {
    (*vars)["Idx"] = as_string(i);
    PrintSourceServerMethod(printer, service->Methods(i).get(), vars);
  }

  // client side
  for (int i = 0; i < service->MethodCount(); ++i) {
    (*vars)["Idx"] = as_string(i);
    PrintSourceClientMethod(printer, service->Methods(i).get(), vars);
    if (i != (service->MethodCount() - 1)) {
      printer->Print(*vars, "\n");
    }
  }
}

std::string GetSourceServices(File* file, const Parameters& params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;
    // Package string is empty or ends with a dot. It is used to fully qualify
    // method names.
    vars["Package"] = file->Package();
    if (!file->Package().empty()) {
      vars["Package"].append(".");
    }
    if (!params.services_namespace.empty()) {
      vars["ns"] = params.services_namespace + "::";
      vars["prefix"] = params.services_namespace;
    } else {
      vars["ns"] = "";
      vars["prefix"] = "";
    }

    for (int i = 0; i < file->ServiceCount(); ++i) {
      if (file->IsCurrentFileService(i)) {
        PrintSourceService(printer.get(), file->Services(i).get(), &vars);
        printer->Print("\n");
      }
    }
  }
  return output;
}

std::string GetSourceEpilogue(File* file, const Parameters& /*params*/) {
  std::string temp;

  if (!file->Package().empty()) {
    std::vector<std::string> parts = file->PackageParts();

    for (auto part = parts.begin(); part != parts.end(); part++) {
      temp.append("}  // namespace ");
      temp.append(*part);
      temp.append("\n");
    }
  }

  return temp;
}

// TODO(mmukhi): Make sure we need parameters or not.
std::string GetMockPrologue(File* file, const Parameters& params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    vars["filename"] = file->FileName();
    vars["filename_base"] = file->FileNameWithoutExt();
    vars["service_header_ext"] = service_header_ext();

    printer->Print(vars, "/*\n");
    printer->Print(vars, " *\n");
    printer->Print(vars, " * Tencent is pleased to support the open source community by making\n");
    printer->Print(vars, " * tRPC available.\n");
    printer->Print(vars, " *\n");
    printer->Print(vars, " * Copyright (C) 2023 Tencent.\n");
    printer->Print(vars, " * All rights reserved.\n");
    printer->Print(vars, " *\n");
    printer->Print(vars, " * Licensed under the Apache License, Version 2.0 (the \"License\");\n");
    printer->Print(vars, " * you may not use this file except in compliance with the License.\n");
    printer->Print(vars, " * You may obtain a copy of the License at\n");
    printer->Print(vars, " *\n");
    printer->Print(vars, " *     http://www.apache.org/licenses/LICENSE-2.0\n");
    printer->Print(vars, " *\n");
    printer->Print(vars, " * Unless required by applicable law or agreed to in writing, software\n");
    printer->Print(vars, " * distributed under the License is distributed on an \"AS IS\" BASIS,\n");
    printer->Print(vars, " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
    printer->Print(vars, " * See the License for the specific language governing permissions and\n");
    printer->Print(vars, " * limitations under the License.\n");
    printer->Print(vars, " *\n");
    printer->Print(vars, " */\n");
    printer->Print(vars, "\n");
    printer->Print(vars, "// Generated by the trpc C++ plugin.\n");
    printer->Print(vars, "// If you make any local change, they will be lost.\n");
    printer->Print(vars, "// source: $filename$\n\n");

    static const char* headers_strs[] = {
        "gmock/gmock.h",
    };
    std::vector<std::string> headers(headers_strs, array_end(headers_strs));
    PrintIncludes(printer.get(), headers, params);
    printer->Print(vars, "\n");

    // printer->Print(vars, "#include \"gmock/gmock.h\"\n\n");

    if (file->AdditionalHeaders().c_str()) {
      printer->Print(vars, file->AdditionalHeaders().c_str());
      printer->Print(vars, "\n");
    }
    printer->Print(vars, "\n");
    printer->Print(vars, "#include \"$filename_base$$service_header_ext$\"\n\n");
  }
  return output;
}

// TODO(mmukhi): Add client-stream and completion-queue headers.
std::string GetMockIncludes(File* file, const Parameters& params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    if (!file->Package().empty()) {
      std::vector<std::string> parts = file->PackageParts();

      for (auto part = parts.begin(); part != parts.end(); part++) {
        vars["part"] = *part;
        printer->Print(vars, "namespace $part$ {\n");
      }
    }

    printer->Print(vars, "\n\n");
  }
  return output;
}

void PrintMockServerMethods(Printer* printer, const Method* method, std::map<std::string, std::string>* vars) {
  (*vars)["Method"] = method->Name();
  (*vars)["Request"] = "flatbuffers::trpc::Message<" + method->InputTypeName() + ">";
  (*vars)["Response"] = "flatbuffers::trpc::Message<" + method->OutputTypeName() + ">";

  if (method->NoStreaming()) {
    printer->Print(*vars,
                   "MOCK_METHOD3($Method$, ::trpc::Status(const ::trpc::ServerContextPtr& context, "
                   "const $ns$$Request$* request, $ns$$Response$* response));\n");
  }
}

void PrintMockClientMethods(Printer* printer, const Method* method, std::map<std::string, std::string>* vars) {
  (*vars)["Method"] = method->Name();
  (*vars)["Request"] = "flatbuffers::trpc::Message<" + method->InputTypeName() + ">";
  (*vars)["Response"] = "flatbuffers::trpc::Message<" + method->OutputTypeName() + ">";

  if (method->NoStreaming()) {
    printer->Print(*vars,
                   "MOCK_METHOD3($Method$, ::trpc::Status(const ::trpc::ClientContextPtr& context, "
                   "const $ns$$Request$& request, $ns$$Response$* response));\n");
    printer->Print(*vars,
                   "MOCK_METHOD2(Async$Method$, "
                   "::trpc::Future<$ns$$Response$>(const ::trpc::ClientContextPtr& context, "
                   "const $ns$$Request$& request));\n");
  }
}
void PrintMockService(Printer* printer, const Service* service, std::map<std::string, std::string>* vars) {
  (*vars)["Service"] = service->Name();

  // server side
  printer->Print(*vars,
                 "class Mock$Service$ : public $Service$ {\n"
                 " public:\n");
  printer->Indent();
  for (int i = 0; i < service->MethodCount(); ++i) {
    PrintMockServerMethods(printer, service->Methods(i).get(), vars);
  }
  printer->Outdent();
  printer->Print("};\n\n");
  // client side
  printer->Print(*vars,
                 "class Mock$Service$ServiceProxy : public $Service$ServiceProxy {\n"
                 " public:\n");
  printer->Indent();
  int method_num = service->MethodCount();
  for (int i = 0; i < method_num; ++i) {
    PrintMockClientMethods(printer, service->Methods(i).get(), vars);
    if (i == method_num - 1) {
      continue;
    }
    printer->Outdent();
    printer->Print("\n");
    printer->Indent();
  }
  printer->Outdent();
  printer->Print("};\n");
}

std::string GetMockServices(File* file, const Parameters& params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;
    // Package string is empty or ends with a dot. It is used to fully qualify
    // method names.
    vars["Package"] = file->Package();
    if (!file->Package().empty()) {
      vars["Package"].append(".");
    }

    if (!params.services_namespace.empty()) {
      vars["services_namespace"] = params.services_namespace;
      vars["ns"] = params.services_namespace + "::";
      vars["prefix"] = params.services_namespace;
      printer->Print(vars, "\nnamespace $services_namespace$ {\n\n");
    } else {
      vars["ns"] = "";
      vars["prefix"] = "";
    }

    for (int i = 0; i < file->ServiceCount(); i++) {
      PrintMockService(printer.get(), file->Services(i).get(), &vars);
      printer->Print("\n");
    }

    if (!params.services_namespace.empty()) {
      printer->Print(vars, "} // namespace $services_namespace$\n\n");
    }
  }
  return output;
}

std::string GetMockEpilogue(File* file, const Parameters& /*params*/) {
  std::string temp;

  if (!file->Package().empty()) {
    std::vector<std::string> parts = file->PackageParts();

    for (auto part = parts.begin(); part != parts.end(); part++) {
      temp.append("} // namespace ");
      temp.append(*part);
      temp.append("\n");
    }
    temp.append("\n");
  }

  return temp;
}

}  // namespace trpc_cpp_generator
